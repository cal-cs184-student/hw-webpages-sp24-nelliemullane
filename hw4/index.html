<html>
	<head>
        <title>CS 184 HW1 Website Writeup</title>
        <meta name="author" content="Nellie E Mullane, Liam Gottesman">
        <link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div class="container">
			<h1>OVERVIEW :</h1>
			<p>
				<br>
				This project 
				<br>
				In part 1, our goal was to build a grid of masses and springs given a json representation of the cloth. We implemented the function buildGrid in the Cloth.cpp file. We iterate through all the point mass positions and generate the point masses while setting their positions and pinning them when necessary. This part had no major problems as it required carefully following the spec.
				<br>
				In part 2, we implemented the simulate method. Our program repeatedly called this method to iteratively update the positions of the point masses using the springs constraints and velvet integration. To accomplish this feat, we first compute the total force acting on a point mass. There are two types of forces, external (which uniformly affect point masses e.g. gravity) and spring correction forces. To calculate the spring correction forces we used Hooke’s law. After, we utilize velvet integration to compute the new point mass positions. Finally, to have the point masses accurately simulate a cloth, we place constraints for the length of each spring modifying the mesh if the constraints are failed. For some time, our cloth was barely moving unless we used a damping coefficient of 0, we reread the spec and figured out that we missed dividing the coefficient by 100.
				<br>
				In part 3, we wanted to have the cloth colliding with two objects: spheres and planes. We implemented the collide method in both objects which updates the position of a point mass if it interferes with the object. To reap the benefits of the collide method, we called it on each point mass iteratively updating the position of each point mass with relation to every object in the scene. There was a problem with the collision when the point masses spawned in at height zero, they would fall under the plane and all other points would remain over the plane. This was because in my collide method, the conditions for being on the positive side should have been inclusive of zero. If it doesn’t include zero, then the points spawned in at height zero would be separated from all the other points that are created on the positive side.
				<br>
				In part 4, the feature that was added is self Collision. This consisted of iterating over all possible pair of point masses checking if they are within a certain distance from each other. If they are within a certain distance then we would correct the positions of the nonpinned point mass/es. This algorithm takes too long and must be optimized using a spatial map. The map divides up space into identical blocks that don’t overlap each other. Then, We run the self collide algorithm on all pairs where the point masses fall within the same block. This spatial map maps a coordinate to a vector that stores point masses that fall within the same block. This part was simple and was simpler then the other parts but included hashing which we haven’t implemented until this point.
				<br>
				In part 5,
			</p>

			<h1> Part 1 :</h1>
			<p>
				Take some screenshots of scene/pinned2.json from a viewing angle where you can clearly see the cloth wireframe to show the structure of your point masses and springs.
				 <br>
				Show us what the wireframe looks like (1) without any shearing constraints, (2) with only shearing constraints, and (3) with all constraints.
				<ol type="1">
					<li>No sheering</li>
					<image src="images/1_noShear.png">
					<li>With only shearing</li>
					<image src="images/1_onlyShear.png">
					<li>With all constraints</li>
					<image src="images/1_all.png">
				</ol>
			</p>
			<h1> Part 2 :</h1>
			<p>
				Experiment with some the parameters in the simulation. To do so, pause the simulation at the start with P, modify the values of interest, and then resume by pressing P again. You can also restart the simulation at any time from the cloth's starting position by pressing R.
				<br>
				Describe the effects of changing the spring constant ks; how does the cloth behave from start to rest with a very low ks? A high ks?
				<br>

				What about for density?
				<br>
				What about for damping?
				<br>
				For each of the above, observe any noticeable differences in the cloth compared to the default parameters and show us some screenshots of those interesting differences and describe when they occur.
				<br>
				Show us a screenshot of your shaded cloth from scene/pinned4.json in its final resting state! If you choose to use different parameters than the default ones, please list them.
				<br>
				<image src="images/2_final.png">
			</p>
			<h1> Part 3 :</h1>
			<p>
				Show us screenshots of your shaded cloth from scene/sphere.json in its final resting state on the sphere using the default ks = 5000 as well as with ks = 500 and ks = 50000.
				<br>
				<pre>                    ks = 5000                                   ks = 500                                      ks = 50000</pre>
				<br>
			</p>
				<image src="images/3_default.png">
				<image src="images/3_500.png">
				<image src="images/3_50000.png">
			<p>
				<br>
				Describe the differences in the results.
				<br>
				<br>
				It seems that as Hooke's constant decreases, the number of folds in the cloth increases. This phenomenon occurs because the lower the constant, the springs in the cloth will be more likely expand to their max constraint. The lack of resistance in the springs will cause the folds to occur more sparingly.
				<br>
				<br>
				Show us a screenshot of your shaded cloth lying peacefully at rest on the plane. If you haven't by now, feel free to express your colorful creativity with the cloth! (You will need to complete the shaders portion first to show custom colors.)
				<br>
				<image src="images/3_plane.png">
			</p>
			<h1> Part 4 :</h1>
			<p>
				
			</p>
			<h1> Part 5:</h1>
			
				
	</body>
</html>